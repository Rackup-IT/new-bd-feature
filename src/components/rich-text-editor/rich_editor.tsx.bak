"use client";

import { Color } from "@tiptap/extension-color";
import { Highlight } from "@tiptap/extension-highlight";
import { Image } from "@tiptap/extension-image";
import Link from "@tiptap/extension-link";
import { Placeholder } from "@tiptap/extension-placeholder";
import { TextStyle } from "@tiptap/extension-text-style";
import { Underline } from "@tiptap/extension-underline";
import { EditorContent, useEditor } from "@tiptap/react";
import { StarterKit } from "@tiptap/starter-kit";

// Import components
import EditorToolbar from "./components/EditorToolbar";
import AIImprovementModal from "./components/AIImprovementModal";
import EditorStats from "./components/EditorStats";
import { toEmbedUrl } from "./utils/videoHelpers";

import { mergeAttributes, Node } from "@tiptap/core";
import { cn } from "../../utils/utils";

import { useEffect, useState } from "react";
import { useAIImprove } from "../../hooks/useAIImprove";
import "./rich_editor.css";

const Tiptap = ({
  onEditorChange,
  value,
}: {
  onEditorChange: (value: string) => void;
  value: string | undefined;
}) => {
  const { improveText, isImproving, error } = useAIImprove();
  const [showAIModal, setShowAIModal] = useState(false);
  const [selectedText, setSelectedText] = useState("");
  const [improvedText, setImprovedText] = useState("");

  // Helper: convert common video URLs (YouTube, Vimeo) to embeddable src; otherwise return original
  const toEmbedUrl = (raw: string) => {
    try {
      const u = new URL(raw, window.location.origin);
      const host = u.hostname.toLowerCase();

      // YouTube watch links -> embed
      if (host.includes("youtube.com")) {
        const v = u.searchParams.get("v");
        if (v) return `https://www.youtube.com/embed/${v}`;
        // handle /shorts/ or /embed/ paths
        const p = u.pathname.split("/").filter(Boolean);
        if (p[0] === "shorts" && p[1])
          return `https://www.youtube.com/embed/${p[1]}`;
        if (p[0] === "embed" && p[1])
          return `https://www.youtube.com/embed/${p[1]}`;
      }

      // youtu.be short links
      if (host === "youtu.be") {
        const id = u.pathname.replace(/^\//, "");
        if (id) return `https://www.youtube.com/embed/${id}`;
      }

      // Vimeo -> player url
      if (host.includes("vimeo.com")) {
        const p = u.pathname.split("/").filter(Boolean);
        const id = p.pop();
        if (id) return `https://player.vimeo.com/video/${id}`;
      }

      // default: return original (may be direct mp4 url or an embeddable src)
      return raw;
    } catch (err) {
      return raw;
    }
  };

  // Video node extension to allow iframe and mp4 embeds to be rendered properly
  const Video = Node.create({
    name: "video",
    group: "block",
    atom: true,
    selectable: true,
    addAttributes() {
      return {
        src: { default: null },
        allow: {
          default:
            "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",
        },
        frameborder: { default: 0 },
        allowfullscreen: { default: true },
        class: { default: "w-full h-64" },
      };
    },
    parseHTML() {
      return [
        { tag: "div.video-embed-wrapper" },
        { tag: "iframe" },
        { tag: "video" },
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const src = HTMLAttributes.src || "";
      const isFile = /\.mp4(\?|$)/i.test(src);
      if (isFile) {
        return [
          "div",
          { class: "video-embed-wrapper" },
          [
            "video",
            { controls: "controls", class: HTMLAttributes.class || "w-full" },
            ["source", { src, type: "video/mp4" }],
          ],
        ];
      }

      return [
        "div",
        { class: "video-embed-wrapper" },
        [
          "iframe",
          mergeAttributes({
            src,
            frameborder: HTMLAttributes.frameborder,
            allow: HTMLAttributes.allow,
            allowfullscreen: HTMLAttributes.allowfullscreen
              ? "true"
              : undefined,
            class: HTMLAttributes.class,
          }),
        ],
      ];
    },
  });

  const editor = useEditor({
    extensions: [
      StarterKit,
      Video,
      Link.configure({ openOnClick: false }),
      Underline,
      TextStyle.configure({ mergeNestedSpanStyles: true }),
      Color,
      Highlight,
      Image.configure({
        HTMLAttributes: {
          class: "editor-image",
        },
        allowBase64: true,
      }),
      Placeholder.configure({ placeholder: "Write something..." }),
    ],
    immediatelyRender: false,
    content: value,
    onUpdate: ({ editor }) => onEditorChange(editor.getHTML()),
  });

  // Autosave to localStorage (debounced)
  useEffect(() => {
    if (!editor) return;
    const id =
      (window.location.pathname || "") + (window.location.search || "");
    let timer: number | undefined = undefined;
    const save = () => {
      try {
        const raw = editor.getJSON();
        localStorage.setItem(`rte-autosave:${id}`, JSON.stringify(raw));
        // optionally also call onEditorChange with current HTML
        onEditorChange(editor.getHTML());
      } catch {
        // ignore
      }
    };

    const handler = () => {
      if (timer) window.clearTimeout(timer);
      timer = window.setTimeout(save, 1500);
    };

    editor.on("update", handler);
    // restore if empty and local exists
    try {
      const saved = localStorage.getItem(`rte-autosave:${id}`);
      if (saved && (!value || value === "" || value === "<p></p>")) {
        const parsed = JSON.parse(saved);
        editor.commands.setContent(parsed);
      }
    } catch {
      // ignore
    }

    return () => {
      editor.off("update", handler);
      if (timer) window.clearTimeout(timer);
    };
  }, [editor, onEditorChange, value]);

  // Allow opening links with Ctrl/Cmd+click or middle-click inside the editor.
  useEffect(() => {
    if (!editor || !editor.view || !editor.view.dom) return;

    const dom = editor.view.dom as HTMLElement;

    const clickHandler = (ev: MouseEvent) => {
      try {
        const target = ev.target as HTMLElement | null;
        if (!target || !target.closest) return;
        const anchor = target.closest("a") as HTMLAnchorElement | null;
        if (!anchor) return;

        // Determine if user intends to open the link:
        // - Ctrl (Windows) or Meta (Mac) modifier
        // - Middle mouse button (button === 1)
        const isModifier = ev.ctrlKey || ev.metaKey || ev.button === 1;
        if (!isModifier) return;

        const href = anchor.getAttribute("href");
        if (!href) return;

        // Open securely in a new tab/window
        window.open(href, "_blank", "noopener,noreferrer");
        ev.preventDefault();
        ev.stopPropagation();
      } catch (err) {
        // swallow errors to avoid breaking editor
        console.error("Editor link open handler error:", err);
      }
    };

    dom.addEventListener("click", clickHandler);
    return () => {
      dom.removeEventListener("click", clickHandler);
    };
  }, [editor]);

  useEffect(() => {
    if (!editor) {
      return;
    }

    const currentContent = editor.getHTML();
    if (value !== currentContent) {
      editor.commands.setContent(value || "<p></p>");
    }
  }, [value, editor]);

  const handleAIImprove = () => {
    if (!editor) return;

    const { from, to } = editor.state.selection;
    const text = editor.state.doc.textBetween(from, to);

    if (!text.trim()) {
      alert("Please select some text to improve");
      return;
    }

    setSelectedText(text);
    setShowAIModal(true);
  };

  // (duplicate helper & node removed)

  const handleImproveConfirm = async () => {
    try {
      const improved = await improveText(selectedText);
      setImprovedText(improved);
    } catch (err) {
      console.error("Failed to improve text:", err);
    }
  };

  const handleApplyImprovement = () => {
    if (!editor) return;

    const { from, to } = editor.state.selection;
    editor
      .chain()
      .focus()
      .deleteRange({ from, to })
      .insertContent(improvedText)
      .run();
    setShowAIModal(false);
    setSelectedText("");
    setImprovedText("");
  };

  const handleCloseModal = () => {
    setShowAIModal(false);
    setSelectedText("");
    setImprovedText("");
  };

  if (!editor) {
    return <p>Loading editor...</p>;
  }

  return (
    <>
      <div className="grid grid-rows-[auto_1fr] h-full w-full min-h-0">
        <EditorToolbar
          editor={editor}
          onAIImprove={handleAIImprove}
          onImageUploadClick={() => document.getElementById("image-upload")?.click()}
          onVideoInsert={(url) => {
            const embed = toEmbedUrl(url.trim());
            editor
              .chain()
              .focus()
              .insertContent({
                type: "video",
                attrs: { src: embed, class: "w-full h-64" },
              })
              .run();
          }}
        />
          <div className="flex items-center gap-1">
            <button
              type="button"
              title="H1"
              onClick={() =>
                editor.chain().focus().toggleHeading({ level: 1 }).run()
              }
              className={cn(
                "p-2 rounded-md",
                editor.isActive("heading", { level: 1 })
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <MdLooksOne className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="H2"
              onClick={() =>
                editor.chain().focus().toggleHeading({ level: 2 }).run()
              }
              className={cn(
                "p-2 rounded-md",
                editor.isActive("heading", { level: 2 })
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <MdLooksTwo className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="H3"
              onClick={() =>
                editor.chain().focus().toggleHeading({ level: 3 }).run()
              }
              className={cn(
                "p-2 rounded-md",
                editor.isActive("heading", { level: 3 })
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <MdLooks3 className="w-4 h-4" />
            </button>
          </div>
          <div className="w-px h-6 bg-gray-200 mx-2" />
          {/* group: core styles */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              title="Bold"
              onClick={() => editor.chain().focus().toggleBold().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("bold") ? "bg-gray-300" : "hover:bg-gray-200"
              )}
            >
              <FaBold className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Italic"
              onClick={() => editor.chain().focus().toggleItalic().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("italic") ? "bg-gray-300" : "hover:bg-gray-200"
              )}
            >
              <FaItalic className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Underline"
              onClick={() => editor.chain().focus().toggleUnderline().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("underline")
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <FaUnderline className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Highlight"
              onClick={() => editor.chain().focus().toggleHighlight().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("highlight")
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <FaPaintBrush className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Text Color"
              onClick={() => {
                const color = window.prompt(
                  "Enter hex color",
                  editor.getAttributes("textStyle").color || "#000000"
                );
                if (color) editor.chain().focus().setColor(color).run();
              }}
              className={"p-2 rounded-md hover:bg-gray-200"}
            >
              <MdFormatColorText className="w-4 h-4" />
            </button>
          </div>
          <div className="w-px h-6 bg-gray-200 mx-2" />
          {/* group: lists & blocks */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              title="Bulleted list"
              onClick={() => editor.chain().focus().toggleBulletList().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("bulletList")
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <FaListUl className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Numbered list"
              onClick={() => editor.chain().focus().toggleOrderedList().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("orderedList")
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <FaListOl className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Blockquote"
              onClick={() => editor.chain().focus().toggleBlockquote().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("blockquote")
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <FaQuoteRight className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Code block"
              onClick={() => editor.chain().focus().toggleCodeBlock().run()}
              className={cn(
                "p-2 rounded-md",
                editor.isActive("codeBlock")
                  ? "bg-gray-300"
                  : "hover:bg-gray-200"
              )}
            >
              <FaCode className="w-4 h-4" />
            </button>
          </div>
          <div className="w-px h-6 bg-gray-200 mx-2" />
          {/* group: insertables */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              title="Insert link"
              onClick={() => {
                const prevHref = editor.getAttributes("link").href || "";
                const url = window.prompt("Enter URL", prevHref || "https://");
                if (url === null) return;
                const trimmed = url.trim();
                if (trimmed === "") {
                  try {
                    editor.chain().focus().unsetLink().run();
                  } catch (err) {
                    console.error("Failed to unset link:", err);
                  }
                  return;
                }

                const openInNew = window.confirm("Open in new tab?");
                const { from, to, empty } = editor.state.selection;
                try {
                  if (empty) {
                    const html = `<a href="${trimmed}" ${
                      openInNew ? 'target="_blank"' : ""
                    }>${trimmed}</a>`;
                    editor.chain().focus().insertContent(html).run();
                  } else {
                    editor
                      .chain()
                      .focus()
                      .extendMarkRange("link")
                      .setLink({
                        href: trimmed,
                        target: openInNew ? "_blank" : undefined,
                      })
                      .run();
                  }
                } catch (err) {
                  console.error(
                    "Link command failed, fallback to inserting HTML:",
                    err
                  );
                  const selected =
                    editor.state.doc.textBetween(from, to) || trimmed;
                  const html = `<a href="${trimmed}" ${
                    openInNew ? 'target="_blank"' : ""
                  }>${selected}</a>`;
                  editor
                    .chain()
                    .focus()
                    .deleteRange({ from, to })
                    .insertContent(html)
                    .run();
                }
              }}
              className={"p-2 rounded-md hover:bg-gray-200"}
            >
              <FaLink className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Insert image"
              onClick={() => document.getElementById("image-upload")?.click()}
              className={"p-2 rounded-md hover:bg-gray-200"}
            >
              <FaImage className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Insert image from URL"
              onClick={() => {
                const url = window.prompt("Enter image URL:");
                if (url) editor.chain().focus().setImage({ src: url }).run();
              }}
              className={"p-2 rounded-md hover:bg-gray-200"}
            >
              <FaImage className="w-4 h-4" />
            </button>
            <button
              type="button"
              title="Insert video"
              onClick={() => {
                const url = window.prompt(
                  "Enter video URL (YouTube/Vimeo/mp4):"
                );
                if (!url) return;
                const trimmed = url.trim();
                const embed = toEmbedUrl(trimmed);

                // Insert as a proper TipTap node so renderHTML handles iframe/video output
                editor
                  .chain()
                  .focus()
                  .insertContent({
                    type: "video",
                    attrs: { src: embed, class: "w-full h-64" },
                  })
                  .run();
              }}
              className={"p-2 rounded-md hover:bg-gray-200"}
            >
              <FaVideo className="w-4 h-4" />
            </button>
          </div>
          <div className="flex-1" />
          {/* special actions */}
          <div>
            <button
              type="button"
              title="AI Improve"
              onClick={handleAIImprove}
              className={
                "p-2 rounded-md bg-purple-100 hover:bg-purple-200 text-purple-800 flex items-center gap-2"
              }
            >
              <FaMagic className="w-4 h-4" />
              <span className="text-xs">AI</span>
            </button>
          </div>
        </div>
        <input
          type="file"
          accept="image/*"
          onChange={(e) => {
            const file = e.target.files?.[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = () => {
                if (reader.result) {
                  editor
                    .chain()
                    .focus()
                    .setImage({ src: reader.result as string })
                    .run();
                }
              };
              reader.readAsDataURL(file);
            }
          }}
          className="hidden"
          id="image-upload"
        />

        <EditorContent
          editor={editor}
          value={value}
          className="h-full border border-gray-200 overflow-auto p-4 bg-white"
        />
        <div className="flex items-center justify-between px-3 py-2 bg-gray-50 border-t">
          <div className="text-xs text-gray-600">
            {(() => {
              const text = editor.state.doc.textContent || "";
              const words = text.trim() ? text.trim().split(/\s+/).length : 0;
              const readMinutes = Math.max(1, Math.round(words / 200));
              return `${words} words Â· ~${readMinutes} min read`;
            })()}
          </div>
          <div className="text-xs text-gray-500">Autosave enabled</div>
        </div>
      </div>

      {/* AI Improvement Modal */}
      {showAIModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4">
            <h3 className="text-lg font-semibold mb-4">AI Text Improvement</h3>

            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Original Text:
                </label>
                <div className="p-3 bg-gray-50 rounded border">
                  {selectedText}
                </div>
              </div>

              {improvedText && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Improved Text:
                  </label>
                  <div className="p-3 bg-green-50 rounded border border-green-200">
                    {improvedText}
                  </div>
                </div>
              )}

              {error && (
                <div className="p-3 bg-red-50 text-red-700 rounded border border-red-200">
                  {error}
                </div>
              )}
            </div>

            <div className="flex gap-3 mt-6">
              {!improvedText ? (
                <>
                  <button
                    onClick={handleImproveConfirm}
                    disabled={isImproving}
                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 disabled:opacity-50"
                  >
                    {isImproving ? "Improving..." : "Improve with AI"}
                  </button>
                  <button
                    onClick={handleCloseModal}
                    className="bg-gray-300 text-gray-700 px-4 py-2 rounded hover:bg-gray-400"
                  >
                    Cancel
                  </button>
                </>
              ) : (
                <>
                  <button
                    onClick={handleApplyImprovement}
                    className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700"
                  >
                    Apply Improvement
                  </button>
                  <button
                    onClick={handleImproveConfirm}
                    disabled={isImproving}
                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 disabled:opacity-50"
                  >
                    {isImproving ? "Re-improving..." : "Try Again"}
                  </button>
                  <button
                    onClick={handleCloseModal}
                    className="bg-gray-300 text-gray-700 px-4 py-2 rounded hover:bg-gray-400"
                  >
                    Cancel
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default Tiptap;
